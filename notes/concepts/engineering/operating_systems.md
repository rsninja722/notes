# operating systems

- **operating system** - program that manages computer hardware, provides a basis for application programs, and acts as a layer between a user and hardware
    - goals
        - efficient use of recourses
        - provide user a convenient way of using a a computer
        - prevent interference in user's activities 

## what do operating systems do

- resource allocation (memory management)
- controls execution of programs (process management)
- storage and file management
- protection and security

## kernel 

- **kernel** - program in main memory that is always running
    - controls execution of other programs
    - other programs interact with kernel through system calls
    - layer between hardware management and rest of OS

## dual mode and system calls

- **dual mode** - allows OS to protect certain parts of the system
    - user mode & kernel mode
    - **mode bit** - bit used to distinguish mode

- **system call (privileged instructions)** - a routine that user programs can use to request actions that require special privileges
    - differs from an ordinary function call in many ways, including access to kernel data, see the example below for more
    - user calls system call setting mode bit to 0, call is executed and on return mode bit is set to 1, return from system call is received in user mode

### APIs

in the context of system calls

TODO

### system call differences example

- Understanding Protection Domains
    - There are two protection domains in the operating system: the user protection domain and the kernel mode protection domain.
- Understanding System Call Execution
    - When a user program invokes a system call, a system call instruction is executed, which causes the processor to begin executing the system call handler in the kernel protection domain.
- Accessing Kernel Data While in a System Call
    - A system call can access data that the calling thread cannot access because system calls execute in the kernel protection domain.
- Passing Parameters to System Calls
    - Parameters are passed to system calls in the same way that parameters are passed to other functions, but some additional calling conventions and limitations apply.
- Preempting a System Call
    - The kernel allows a thread to be preempted by a more favored thread, even when a system call is executing. This capability provides better system responsiveness for large multi-user systems.
- Handling Signals While in a System Call
    - Signals can be generated asynchronously or synchronously with respect to the thread that receives the signal. An asynchronously generated signal is one that results from some action external to a thread. It is not directly related to the current instruction stream of that thread. Generally these are generated by other threads or by device drivers.
- Handling Exceptions While in a System Call
    - Exceptions are detected by the processor as a result of the current instruction stream.
- Understanding Nesting and Kernel-Mode Use of System Calls
    - The operating system supports nested system calls with some restrictions. System calls (and any other kernel-mode routines running under the process environment of a user-mode process) can use system calls that pass all parameters by value.
- Page Faulting within System Calls
    - Most data accessed by system calls is pageable by default. This includes the system call code, static data, dynamically allocated data, and stack. As a result, a system call can be preempted in two ways:
- Returning Error Information from System Calls
    - Error information returned by system calls differs from that returned by kernel services that are not system calls. System calls typically return a special value, such as -1 or NULL, to indicate that an error has occurred.
- System Calls Available to Kernel Extensions
    - The system calls are grouped according to which subroutines call them.

## process & programs

- program - passive entity stored on disk
- process (aka tasks)- active entity being executed

- different names for the same data depending on whats being done with it

### system programs

#### continuously running system programs

## interrupts

- **interrupts** - enables a device/software to notify the CPU that it needs attention
    - caused through hardware signals via system bus, or by program system calls

- types of interrupts
    - **trap/exception** - caused by an error or a user request

### interrupt handling

- interrupts require OS to stop and handle the interrupt

- handling steps
    - cpu stops executing current task
    - preservers state of cpu in registers and program counter
    - transfers execution to the starting address of the **interrupt service routine** (ISR)
    - ISR handles interrupt, then resumes interrupted process

- implementation
    - as a routine - slow and inefficient
    - interrupt vector - use a predefined table of pointers to various interrupt routines

## computer startup

- first loads a **bootstrap program** stored on a reserved part of ROM (generally known as **firmware**)
- then the bootstrap programs loads kernel and system programs (system daemons)

## multiprogramming 

- OS organizes jobs for the CPU to execute
- **job scheduling** - how an OS selects which job to run
    - when one program is waiting (example: for I/O), the OS switches to another job

### timesharing

- CPU switches jobs so frequently that users can interact with each job while running (**interactive computing**)
- response time should be < 1 second
- 


## timer

- a hardware component that can be set to interrupt the computer after a specified period
    - helps prevent infinite loops / process hogging resources
    - OS maintains a counter which decrements and generates an interrupt when 0 is reached 
    - setting the timer is a privileged instruction

## virtualization

- an abstraction of computer hardware
- **virtual machine management

TODO

## command line interpreter (CLI)

- aka shells
- allows direct command entry to the OS
TODO

# structure of operating systems

## monolithic

## layered

## microkernel

## modular

- kernel has separate core components with clearly defined interfaces
- additional services linked in via modules (at boot time or run time)
- each module is loaded as needed
- TODO

## hybrid